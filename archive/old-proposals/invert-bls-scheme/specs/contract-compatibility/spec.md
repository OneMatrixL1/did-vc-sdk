# Spec: SDK Contract Compatibility

**Capability**: SDK Native BLS Key Generation and Signing
**Change Type**: ADDED

---

## ADDED Requirements

### Requirement: SDK SHALL generate BLS keypairs compatible with contract

The SDK SHALL provide native BLS12-381 keypair generation that produces keys compatible with the updated contract's inverted signature scheme.

**Rationale**: Enables developers to generate fresh BLS keys without external services.

#### Scenario: SDK generates valid BLS keypair

**Given** the SDK is initialized
**When** generating a new BLS keypair
**Then** the SDK SHALL use `@noble/curves/bls12-381` library
**And** the secret key SHALL be 32 bytes
**And** the public key SHALL be G1 point (48 bytes compressed)
**And** the public key SHALL be derivable to an Ethereum address

#### Scenario: Generated keypair works with contract

**Given** a BLS keypair generated by the SDK
**And** a message signed with the private key
**When** calling the contract's `changeOwnerWithPubkey()` with SDK-generated data
**Then** the contract SHALL accept the public key
**And** the contract SHALL verify the signature successfully
**And** the owner change SHALL complete

---

### Requirement: SDK SHALL sign messages with BLS private key

The SDK SHALL provide BLS signing functionality that produces G2 signatures compatible with the contract.

**Rationale**: Completes the end-to-end flow of key generation → signing → contract interaction.

#### Scenario: SDK signs EIP-712 message hash

**Given** a BLS private key generated by the SDK
**And** an EIP-712 message hash from `createChangeOwnerWithPubkeyHash()`
**When** signing the message hash with BLS private key
**Then** the SDK SHALL produce a G2 signature (96 bytes compressed)
**And** the signature SHALL be expandable to 192 bytes uncompressed if needed
**And** the signature SHALL be valid for contract verification

#### Scenario: Signature can be verified locally

**Given** a message signed with SDK's BLS signing
**And** the corresponding BLS public key
**When** verifying the signature locally using `bls.verify()`
**Then** the verification SHALL succeed
**And** this confirms the signature is cryptographically valid

---

### Requirement: SDK SHALL support signature format conversion

The SDK SHALL handle conversion between compressed (96 bytes) and uncompressed (192 bytes) G2 signatures as needed by the contract.

**Rationale**: Contract may require uncompressed format while SDK generates compressed.

#### Scenario: SDK expands compressed G2 signature

**Given** a compressed G2 signature (96 bytes) from `bls.sign()`
**When** the contract requires uncompressed format (192 bytes)
**Then** the SDK SHALL provide a method to expand the signature
**And** the expanded signature SHALL be valid for contract verification

---

### Requirement: EIP-712 hash generation SHALL remain unchanged

The SDK's `createChangeOwnerWithPubkeyHash()` method SHALL continue to generate the same EIP-712 message hashes as before.

**Rationale**: Hash generation is independent of the BLS signature scheme used.

#### Scenario: Hash generation matches contract expectations

**Given** an identity, current owner, and new owner
**When** generating the EIP-712 hash with `createChangeOwnerWithPubkeyHash()`
**Then** the hash SHALL use `CHANGE_OWNER_WITH_PUBKEY_TYPEHASH`
**And** the hash SHALL use the contract's `DOMAIN_SEPARATOR`
**And** the hash SHALL match manual computation using contract constants
**And** this behavior SHALL be identical to before the BLS scheme change

---

### Requirement: SDK SHALL provide complete BLS workflow

The SDK SHALL provide a complete workflow from key generation to contract interaction without external dependencies.

**Rationale**: Improved developer experience and self-contained functionality.

#### Scenario: End-to-end BLS owner change workflow

**Given** the SDK is initialized with a deployed contract
**When** executing a complete BLS-based owner change
**Then** the SDK SHALL:
1. Generate a fresh BLS keypair
2. Derive the Ethereum address from public key
3. Set the BLS address as current owner (via `changeOwner()`)
4. Generate EIP-712 message hash for new owner change
5. Sign the hash with BLS private key
6. Call `changeOwnerWithPubkey()` with all parameters
7. Verify the transaction succeeds on-chain
**And** all steps SHALL work without external BLS services

---

### Requirement: SDK SHALL maintain backward compatibility for non-BLS features

Changes to support inverted BLS scheme SHALL NOT affect other SDK functionality.

**Rationale**: BLS changes are isolated to BLS-specific features.

#### Scenario: Non-BLS owner changes still work

**Given** an identity managed by the SDK
**When** performing regular owner change via `changeOwner()`
**Then** the functionality SHALL work exactly as before
**And** no BLS-related changes SHALL affect this flow

#### Scenario: DID resolution still works

**Given** a DID to resolve
**When** using SDK's DID resolution features
**Then** the resolution SHALL work exactly as before
**And** BLS scheme changes SHALL NOT affect resolution

---

## MODIFIED Requirements

### Requirement: SDK integration tests SHALL use fresh keypairs

SDK integration tests SHALL generate fresh BLS keypairs instead of relying on pre-signed test vectors.

**Previous Behavior**: Tests used hardcoded test vectors from ethr-did-registry
**New Behavior**: Tests generate keys dynamically with `@noble/curves/bls12-381`

#### Scenario: Integration tests generate fresh keys

**Given** the integration test suite
**When** running BLS-related tests
**Then** each test SHALL generate a new BLS keypair
**And** each test SHALL sign messages with generated keys
**And** tests SHALL verify against the deployed contract
**And** all tests SHALL pass with dynamically-generated data

---

## Implementation Notes

### Key Generation

```typescript
import { bls12_381 as bls } from '@noble/curves/bls12-381';

export function generateBlsKeypair() {
    const secretKey = bls.utils.randomPrivateKey();  // 32 bytes
    const publicKey = bls.getPublicKey(secretKey);    // 48 bytes (G1 compressed)
    return {
        secretKey,
        publicKey,
        publicKeyHex: '0x' + Buffer.from(publicKey).toString('hex')
    };
}
```

### Signing

```typescript
export function signWithBls(message: Uint8Array, secretKey: Uint8Array) {
    const signature = bls.sign(message, secretKey);  // 96 bytes (G2 compressed)
    return {
        signature,
        signatureHex: '0x' + Buffer.from(signature).toString('hex')
    };
}
```

### Signature Expansion (if needed)

```typescript
// If contract requires uncompressed G2 (192 bytes)
export function expandG2Signature(compressed: Uint8Array): Uint8Array {
    // Implementation depends on @noble/curves API
    // May need to unmarshal and re-marshal in uncompressed format
}
```

### End-to-End Example

```typescript
// Generate keypair
const { secretKey, publicKeyHex } = generateBlsKeypair();

// Derive address
const blsAddress = deriveAddressFromG1(publicKeyHex);

// Set as owner
await controller.changeOwner(blsAddress);

// Create message hash
const messageHash = await controller.createChangeOwnerWithPubkeyHash(newOwner);

// Sign
const { signatureHex } = signWithBls(ethers.getBytes(messageHash), secretKey);

// Call contract
await registry.changeOwnerWithPubkey(
    identity,
    blsAddress,
    newOwner,
    publicKeyHex,
    signatureHex
);
```

---

## Testing Requirements

- [ ] Test fresh BLS keypair generation
- [ ] Test BLS signing produces valid G2 signatures
- [ ] Test signature format conversion (if needed)
- [ ] Test EIP-712 hash generation unchanged
- [ ] Test end-to-end workflow with fresh keys
- [ ] Test backward compatibility for non-BLS features
- [ ] Update `e2e-bls-verified.test.ts` to use dynamic key generation
- [ ] Ensure all 9+ tests pass with fresh keys

---

## Migration Impact

**Breaking Change**: NO (for SDK users who don't use BLS)

- Non-BLS features remain unchanged
- BLS features now work natively (improvement, not breaking change)
- Test data changes (internal, not user-facing)

**For BLS Users**:
- Can now generate keys natively (new capability)
- No longer need external signing services (improvement)
- Contract addresses may change (deployment-related)

---

**Last Updated**: 2025-12-25
**Status**: Proposed
